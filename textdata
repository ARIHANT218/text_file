Data Analysis .....
Numpy , Pandas is a open source library of python.
Pandas is used for manipulate and perform operation on Data.
Numpy is used to handle the array Numpy.
Import Pandas as py
import Numpy as np

import matplotlip.

it is a open source python libraries which is used fordata manipulation and graphs.


1....

TCP /IP .. TRANSMISSION CONTROL PROTOCOLS OR INTERNET PROTOCOL THAT GUARANTEES RELIABLE COMMUNICATION BEW COMPUTERS BY ESTABLISHING A CONNECTION, MANAGING DATA TRANSFER AND MAKING SURE DATA ARRIVES .
Layers ..
APPLICATION LAYER , TRANSPORT LAYER, INTERNET LAYER, NETWORK INTERFACE LAYER , Data link layer 


SYATEM CALL ... when user send a request to the kernel for operation like file management and memory management.
kernel ... IT is a core part of OS .IS IS USED FOR RESOURCES MANAGEMENT AND HARDWARE, SOFTWARE COMMUNICATION AND ALSO MAN
AGE LOW LEVEL TASK LIKE MEMORY MANAGEMENT, SCHEDULING ETC ..


Software Engineer 
Requirement For Software Eng
Risk management and SE 
Cohestion and coupling 



1. Polymorphism  : It is the concept of oops. Polymorphism is the ability of a single function and methos or operator behave differently
based of the input .
Type of polymorphism :
1. Compile time ploy  2. run time ploy
Compile time polymorphism --Occur when the method to be executed is determined at compile time. ususallly operator overloading ..
run time ploy -- Occurs when the method to be executed is determined at run time ploy .

Inheritance : It is the concept of oops . When derive class access the property and charac  of the parent class is known as inheritance.
 In java Multiple inheritance is not possible . Using interface can be implement multpile inheritance . 

Interafce is just like a class , which contains the abstract methods and variables . 

Encapsulation : it is the concept of oops .  Encapsulation  wrapped the method and variables into the single unit . AND ALSO HIDING THE DATA FROM USER
 . BY DECLARE  THE CLASS WRAAPED  THE METHOS AND VARIABLES AND USING MODIFIER LIKE PRIVATE AND PROTECT 
EASLY HIDE THE DATA FROM USER .


Abstraction in Java : IT HIDING THE INTERNAL IMPLEMENTATION DETAILS AND SHOWONLY ESSENTIAL DETILS TO THE USER.
IN JAVA TWO WAYS ARE POSSIBLE ...
1. INTERFACE  2.  ABSTRACT CLASSES.  ... RFEAL LIFE EXAMPLE IS TV AND BUTTON

----
2...
What is computer network? 
COMPUETR NETWORK IS THE SYSTEM WHERE TWO OR MORE  COMPUTERS AND DEVICES ARE CONNECTED TO  SHARE  DATA , RESOUCES , AND COMMUNICATE.
These devices communicate using wired (Ethernet cables) or wireless (Wi-Fi, Bluetooth) connections.

Types of Computer Networks:

LAN (Local Area Network) – Connects devices within a limited area (e.g., home, office).
WAN (Wide Area Network) – Covers large geographical areas (e.g., the internet).
MAN (Metropolitan Area Network) – Connects multiple LANs within a city.
PAN (Personal Area Network) – A small network for personal devices (e.g., Bluetooth).

 ----
3...

What is an IP Address?
IP adddress or Internet Protocols address is unique identifier which is assign to each devices connected to the network.

there are two version of IP add.
- IPv4 -- 32 bit  , IPV6  -- 128 bit 


4...
What is a VPN?
Virtual Private Network is create a secure connection over a network bew the your device and another device network .
it encurpts the data so that unorthised user is not directly access the information.

-----

Structure...
DNS .. DOMAIN NAME SYSTEM... USED FOR FIND THE IP address of Server.. Basically Browse jse the dns request to finding the server ip address and then send a request to server

--
Router -- it connect the multiple networks with each oher.. and it store the IP address .
Switvh -- Connect the multiple devices together in a network and also store the MAC address  , itshare the data for particular devices .
HUB - connect device with network and not store  MAC or IP . i t send data to all devices.


class Solution {
    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        int n = fruits.length;
        boolean[] used = new boolean[n]; // Mark used baskets
        int unplaced = 0;

        for (int i = 0; i < n; i++) {
            boolean placed = false;
            for (int j = 0; j < n; j++) {
                if (!used[j] && baskets[j] >= fruits[i]) {
                    used[j] = true; // Assign basket
                    placed = true;
                    break;
                }
            }
            if (!placed) {
                unplaced++;
            }
        }

        return unplaced;
    }
}
-----------------------------------------------------------------------------------------------------------------

✅ Problem Statement Summary
Rules:

Each fruit must be placed in the leftmost basket that can fit it.

Once a basket is used, it cannot be reused.

If a fruit can't be placed in any basket, it is unplaced.
code: 

int n = fruits.length;
boolean[] used = new boolean[n]; 

int unplaced = 0;

for (int i = 0; i < n; i++) {
    boolean placed = false;
    for (int j = 0; j < n; j++) {
        if (!used[j] && baskets[j] >= fruits[i]) {
            used[j] = true;
            placed = true;
            break;
        }
  if (!placed) {
      unplaced++;
  }

 return unplaced;
TC -- O(n2);
optimise..

public class Solution {
    int[] tree;
    int n;

    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        n = baskets.length;
        tree = new int[4 * n];
        build(baskets, 0, 0, n - 1);

        int unplaced = 0;
        for (int fruit : fruits) {
            int index = query(0, 0, n - 1, fruit);
            if (index == -1) {
                unplaced++;
            } else {
                update(0, 0, n - 1, index, -1); // mark as used
            }
        }
        return unplaced;
    }

    // Build segment tree
    private void build(int[] baskets, int node, int l, int r) {
        if (l == r) {
            tree[node] = baskets[l];
            return;
        }
        int mid = (l + r) / 2;
        build(baskets, 2 * node + 1, l, mid);
        build(baskets, 2 * node + 2, mid + 1, r);
        tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);
    }

    // Query leftmost index with value >= val
    private int query(int node, int l, int r, int val) {
        if (tree[node] < val) return -1;
        if (l == r) return l;

        int mid = (l + r) / 2;
        int left = query(2 * node + 1, l, mid, val);
        if (left != -1) return left;
        return query(2 * node + 2, mid + 1, r, val);
    }

    // Update a basket to mark it as used
    private void update(int node, int l, int r, int idx, int value) {
        if (l == r) {
            tree[node] = value;
            return;
        }
        int mid = (l + r) / 2;
        if (idx <= mid) update(2 * node + 1, l, mid, idx, value);
        else update(2 * node + 2, mid + 1, r, idx, value);

        tree[node] = Math.max(tree[2 * node + 1], tree[2 * node + 2]);
    }



question...

Got it — you’re asking about **LeetCode 808: Soup Servings**.

This is a probability + dynamic programming problem where we simulate all serving possibilities recursively, storing results in a memo table for efficiency.

---
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
## **Approach**

1. **Convert mL to “serving units” of 25 mL**

   * Since all operations are multiples of 25 mL, we can scale down:

     ```
     n = ceil(n / 25)
     ```
   * That way, instead of serving 100 mL, we serve `4 units`, 75 mL → `3 units`, etc.

2. **Recursive function `dfs(a, b)`**:

   * `a` = remaining units of soup A
   * `b` = remaining units of soup B
   * Base cases:

     * If `a <= 0` and `b <= 0`: return `0.5` (both empty same time)
     * If `a <= 0` and `b > 0`: return `1.0` (A finished first)
     * If `a > 0` and `b <= 0`: return `0.0` (B finished first)

3. **Recursive transitions**:

   * Each of the 4 operations happens with probability `0.25`:

     ```
     (4,0), (3,1), (2,2), (1,3)
     ```

     We average the probabilities of these next states.

4. **Optimization for large `n`**:

   * For large starting values (`n > 4800` in mL), the probability approaches `1.0` and we can directly return `1.0` to avoid TLE.

---------------------------------------------------------------------------------------------------------------

## **Java Code**

```java
class Solution {
    Double[][] memo;

    public double soupServings(int n) {
        // Scale down by 25 mL units
        n = (int) Math.ceil(n / 25.0);

        // Optimization: for large n, probability is ~1
        if (n > 200) return 1.0;

        memo = new Double[n + 1][n + 1];
        return dfs(n, n);
    }

    private double dfs(int a, int b) {
        if (a <= 0 && b <= 0) return 0.5; // both empty same time
        if (a <= 0) return 1.0;           // A empty first
        if (b <= 0) return 0.0;           // B empty first

        if (memo[a][b] != null) return memo[a][b];

        // Four possible serving options, each with probability 0.25
        double prob = 0.25 * (dfs(a - 4, b) +
                              dfs(a - 3, b - 1) +
                              dfs(a - 2, b - 2) +
                              dfs(a - 1, b - 3));

        memo[a][b] = prob;
        return prob;
    }
}
```

---------------------------------------------------------------------------------------------------------------

## **Complexity**

* **Time**: `O(n²)` for DP states.
* **Space**: `O(n²)` for memoization table.

---

If you like, I can also give you a **step-by-step dry run** for `n = 50` mL so you see exactly how the probability builds from base cases upward. That will make the recursion and memoization crystal clear.

Given an integer n, return true if it is a power of two. Otherwise, return false.

class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0) return false;
        while (n % 2 == 0) {
            n /= 2;
        }
        
        return n == 1;
    }
}

------------------------------------------------------------------------------------------------------------
--------------------
869. Reordered Power of 2

class Solution {
    private static final Set<String> powerSet = new HashSet<>();
    
    static {
        for (int i = 0; i < 31; i++) {
            int power = 1 << i; // 2^i
            char[] digits = String.valueOf(power).toCharArray();
            Arrays.sort(digits);
            powerSet.add(new String(digits));
        }
    }
    
    public boolean reorderedPowerOf2(int n) {
        char[] digits = String.valueOf(n).toCharArray();
        Arrays.sort(digits);
        return powerSet.contains(new String(digits));
    }


------------------------------------------------------------------------------------------------------------
2438. Range Product Queries of Powers
import java.util.*;

class Solution {
    public int[] productQueries(int n, int[][] queries) {
        List<Integer> powerList = new ArrayList<>();
        long M = 1_000_000_007;

        // Get all powers of 2 from n
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0) {
                powerList.add(1 << i);
            }
        }

        List<Integer> ans = new ArrayList<>();

        // Process each query
        for (int i = 0; i < queries.length; i++) {
            int start = queries[i][0];
            int end = queries[i][1];
            long product = 1;

            for (int j = start; j <= end; j++) {
                product = (product * powerList.get(j)) % M;
            }
            ans.add((int) product);
        }

        // Convert List<Integer> to int[]
        int[] result = new int[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            result[i] = ans.get(i);
        }
        return result;
    }
}


--------------------------------------------------------------------------------------------------------------


Ways to Express an Integer as Sum of Powers

class Solution {
    int M = 1000_000_007;
    int solve(int n , int num , int x , int [][] dp){
        if(n==0) return 1;
        if(n<0) return 0;
        int currPower = (int) Math.pow(num,x);

       if (currPower > n) return 0;
       if(dp[n][num] != -1) return dp[n][num];

        int take = solve(n-currPower, num+1 ,x,dp);
        int skip= solve(n, num+1, x,dp);
        return dp[n][num] = (take+skip ) %M;



    }
    public int numberOfWays(int n, int x) {
        int [][] dp = new int [301][301];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }
        return solve(n,1,x,dp);

    }
}
------------------------------------------------------------------------------------------------------------



QUESTION LEETCODE -- 
class Solution {
    public String largestGoodInteger(String num) {
        String ans = "";
        
        for (int i = 0; i <= num.length() - 3; i++) {
            // Check if three consecutive digits are the same
            if (num.charAt(i) == num.charAt(i + 1) && num.charAt(i) == num.charAt(i + 2)) {
                String triple = num.substring(i, i + 3);
                // Update ans if it's larger in lexicographical order
                if (ans.isEmpty() || triple.compareTo(ans) > 0) {
                    ans = triple;
                }
            }
        }
        
        return ans;
    }
}

------------------------------------------------------------------------------------------------------------


class Solution {
    public int longestValidParentheses(String s) {
        Stack<Integer> st = new Stack<>();
        st.push(-1);  // base index for valid substring
        int maxLen = 0;

        for(int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);

            if(ch == '(') {
                st.push(i);  // store index of '('
            } else {
                st.pop();    // try to match with previous '('
                if(st.isEmpty()) {
                    st.push(i); // reset base index
                } else {
                    maxLen = Math.max(maxLen, i - st.peek());
                }
            }
        }
        return maxLen;
    }
}
HOUSE ROBBERS _II


class SolutionCircular {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        return Math.max(robLinear(nums, 0, n - 2), robLinear(nums, 1, n - 1));
    }
    private int robLinear(int[] nums, int start, int end) {
        int prev2 = 0, prev1 = 0;
        for (int i = start; i <= end; i++) {
            int take = prev2 + nums[i];
            int skip = prev1;
            int current = Math.max(take, skip);
            prev2 = prev1;
            prev1 = current;
        }
        return prev1;
    }
}

import java.util.*;

class FreqStack {
    private Map<Integer, Integer> freq; // element -> frequency
    private Map<Integer, Stack<Integer>> group; // frequency -> stack of elements
    private int maxFreq;

    public FreqStack() {
        freq = new HashMap<>();
        group = new HashMap<>();
        maxFreq = 0;
    }

    public void push(int x) {
        // Increase frequency
        int f = freq.getOrDefault(x, 0) + 1;
        freq.put(x, f);

        // Update maxFreq
        if (f > maxFreq) {
            maxFreq = f;
        }

        // Add to group
        group.computeIfAbsent(f, z -> new Stack<>()).push(x);
    }

    public int pop() {
        // Get most frequent element
        Stack<Integer> stack = group.get(maxFreq);
        int x = stack.pop();

        // Decrease frequency count
        freq.put(x, freq.get(x) - 1);

        // If stack is empty, reduce maxFreq
        if (stack.isEmpty()) {
            maxFreq--;
        }

        return x;
    }
}


_______________________________________________

import java.util.*;

class Solution {
    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {
        // Step 1: Build adjacency list (manager -> subordinates)
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            tree.add(new ArrayList<>());
        }
        for (int emp = 0; emp < n; emp++) {
            if (manager[emp] != -1) {
                tree.get(manager[emp]).add(emp);
            }
        }

        // Step 2: DFS function
        return dfs(headID, tree, informTime);
    }

    private int dfs(int emp, List<List<Integer>> tree, int[] informTime) {
        int maxTime = 0;
        for (int sub : tree.get(emp)) {
            maxTime = Math.max(maxTime, dfs(sub, tree, informTime));
        }
        return informTime[emp] + maxTime;
    }
}



......................................

410. Split Array Largest Sum.----------------------------

💡 Approach (Binary Search + Greedy)

This is a binary search on the answer problem.

The minimum possible largest sum is max(nums) (because each element must be inside some subarray).

The maximum possible largest sum is sum(nums) (if we take the whole array as one subarray).

Use binary search between these two values:

For a mid value, check if we can split the array into ≤ k subarrays where each subarray sum ≤ mid.

If yes → try smaller values (move right boundary).

If no → increase the mid (move left boundary).

This way we minimize the largest sum.


code ........
class Solution {
    public int splitArray(int[] nums, int k) {
        int left = 0, right = 0;
        for (int num : nums) {
            left = Math.max(left, num);  // at least the largest single element
            right += num;               // at most the total sum
        }

        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canSplit(nums, k, mid)) {
                right = mid; // try smaller largest sum
            } else {
                left = mid + 1; // need bigger largest sum
            }
        }
        return left; // or right, both same here
    }

    private boolean canSplit(int[] nums, int k, int maxSum) {
        int count = 1;  // at least one subarray
        int currentSum = 0;

        for (int num : nums) {
            if (currentSum + num > maxSum) {
                count++;
                currentSum = num;
                if (count > k) return false;
            } else {
                currentSum += num;
            }
        }
        return true;
    }
}
----------------------------------------------------------
973. K Closest Points to Origin

Approach 1: Max Heap (Priority Queue)

Use a max heap of size k.

Store points by their distance to origin.

If heap size exceeds k, remove the farthest point.

Finally, extract all points from the heap.

✅ Time Complexity: O(N log K)
✅ Space Complexity: O(K)

Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).

import java.util.*;

class Solution {
    public int[][] kClosest(int[][] points, int k) {
        // Max Heap: store [distance, x, y]
        PriorityQueue<int[]> maxHeap = new PriorityQueue<>(
            (a, b) -> b[0] - a[0] // sort by distance (max heap)
        );

        for (int[] point : points) {
            int dist = point[0] * point[0] + point[1] * point[1];
            maxHeap.offer(new int[]{dist, point[0], point[1]});

            if (maxHeap.size() > k) {
                maxHeap.poll(); // remove farthest point
            }
        }

        // Build result from heap
        int[][] result = new int[k][2];
        for (int i = 0; i < k; i++) {
            int[] entry = maxHeap.poll();
            result[i][0] = entry[1]; // x
            result[i][1] = entry[2]; // y
        }
        return result;
    }
}
// nlogK TC   // SC K


